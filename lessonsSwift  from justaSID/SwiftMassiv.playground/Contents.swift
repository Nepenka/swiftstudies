import UIKit

/*let array = Array<Int>(arrayLiteral: 1,2,3,4,5,6,7,8)
                    
let array2: Array<Int> = [1,2,3,4,5,6,7,8]
let array3 = [1,2,3,4,5,6 ] //предпочтильней является именно вот эта запись массива
let array4: [Int] = [1,2,3,4,5,6]
let array5 = Array<Double>()
let array6: [Int] = []
//А если мы допусти создать массив из 100 элементов без использования литерала
var array7 = Array(repeating: 1.5, count: 20) //и при выводе этого значения в консоль мы видим что данный масси имеет 20 значений внутри себя
//print(array7)
//так же ещё является частью работы,очень часто, обьединение двух массивов в один
var array8 = array + [6,6,6,6,6,6] + array2 //таким образом мы обьединяем массив и можем даже при обьединение массивов которые мы указали ранее добавить ещё один литерал массива(шстёрки которые мы добавили являются тем самым литералом)
//Для того чтобы массив был изменяемым мы должны объявить его с помощью переменной var и в таком случае мы моем что-нибудь добавить в этот самый массив
var array9 = [1,2,3,4] //и щас мы просто инициализируем значение массива 9 в 10
var array10 = array9
//Чтобы обратиться к какому-то элементу из массива нам нужно будет сделать следующим образом:
array9[0] // в скобочках мы вписываем его индекс за счёт чего мы и узнаем какой-то элемент который хранится в этом самом массиве
//но для того чтобы каждое из этих значений можно было изменить
array9[0] = 5
array10 [0] = 5 //в этом случае мы получим ошибку если попытаем присвоить значение 5 или внести его в массив, потому что array 10 у нас является константой(let) и в неё нельзя ничего вносить. А в первом случае наоборот всё изменится потому что у нас стоит переменная (var) котора на позволяет без ошибочно менять выражение в массиве
//так же мы можем обратиться не к определнному элемменту массива а к целому диапазону значений
array10[1...3] = [5,6,7,8,9,10]
array10
*/



//МЕТОДЫ МАССИВА

/*var array = [1,2,3,4,57,8,9,0,1]
var array1 = [Int]()

//для того чтобы узнать сколько элементов внутри массива можно воспользоваться методом count
array.count
//Для того чтобы узнать пустой массив или нет мы можем воспользоваться методом
array.isEmpty //этот метод выдает нам false в том случае если массив не пустой и true если массив пустойю Я могу показать это прямо сейчас на примере
array1.isEmpty
//Так же как и у строк мы можем получить какой-то его индекс например
array.startIndex
array.endIndex
//так же есть метод reverse который служит для того чтобы перевернуть все значения массива
//array.reverse()
//Так же мы можем найти максимальное и минимальное значение
array.min()
array.max()
//так же для того чтобы вставить какое-нибудь значение в массив
array.append(11)
//если нам нужно прибавить целую коллекцию элементов
array.append(contentsOf: [1,2,3,4,5])
//То есть мы можем прибавить в конец массива, либо один элемент либо сразу много
//Так же значение массива можно вставить в любое другое место если мы знаем его индекс
array.insert(11, at: 3)
//Так же это можно записать по-другому
array.insert(99, at: array.endIndex) //Здесь мы вставляем его в конец
array.insert(99, at: array.startIndex) //А здесь в самое начало
//помимо вставки можно удалять какие-то элементы массива
array.remove(at: 5)
print(array)
//при использовании метода removeAll мы удаляем все значениея из массива
//Так же мы можем удалить первый элемент массива
array.removeFirst()
print(array)
//Так же с помощью другого метода мы можем удалить последний элемент массива
array.removeLast()
print(array)
//Ещё по массивам можно проводить иттерации для этого можно воспользоваться циклом
for item in array{
    print(item)
}
//Если вам кроме самих значения элемента нужны ещё и их индексы, мы можем воспользоваться другой конструкцией
for (index,item) in array.enumerated(){
    print("Index is \(index), value is \(item)")
}
 */

//Задание с массивами уровень с ***
var array = [1,2,3,4,57,8,9,0,1] as [Double] //И теперь мы можем посмотреть какого же типа наш массив
type(of: array)
//И несмотря на то что мы инициализировали его значениями типа int он у нас всё равно получился со значением типа Double
//И ещё один момент если мы попробуем инициализировать так с типа Int
/*var array2 = [1,2,3,4,6,7 as Float] //И если у нас хотя бы одно значение в массиве типа Float у нас выведется значение что у нас весь массив типа Float
type(of: array2)
*/
var arr5x5 = Array(repeating: Array(repeating: 25, count: 5), count: 5) //И теперь мы получаем не одномерный массив как раньше, а мы получаем в этом случае массив массивов

//Так же щас рассмотрим интересный пример массива
var arr3 = [1,2,3,4,5,6,7,8,9]
var arr4 = [11,22,33,44,55]
//Теперь мы возьмём их сложим в один массив и перемешаем
var arr5 = (arr3 + arr4).shuffled()
//В итоге в arr5 хранятся элементы из двух други массивов так + они ещё и перемешаны
//Теперь мы найдем индексы тех элементов которые мы закинули из arr4 в arr5
for (index,item) in arr5.enumerated() where arr4.contains(item){
    print(index)
    
}
//Так же как решается большая проблема с индексами когда мы е можем обратиться
//arr4[100] //компилятор в таком случае выдаёт нам ошибку, но как же можно решить эту проблему?
extension Array {
    /* попробуем переопределить сабскрипт*/ public subscript(safe index: Int)  -> Element?{
        return indices ~= index ? self[index] : nil
    } //и он будет возвращать у нас опциональный элемент
}
//indices - это ренч всех индексов в массиве
arr4[safe: 100]
//В итоге у нас не будет ошибки если мы впишем не существующий элемент, он просто вернёт нам nil
var a = arr4[safe: 4]
type(of: a)
//Мы посмотрели какого типа будет наша a который мы присвоили arr4


//А теперь поговорим о некоторых методах массива которые часто используются
//Начнем с метода filter который нужен для того чтобы отфильтровать какие-нибудь значения по поределённому правилу и соответсвенно вернуть другой массив
var arr6 = array.filter { (value) -> Bool in
    return value < 5
}

array
arr6
//теперь поговорим про метод map
var arr7 = array.map { (value) -> Double in
    return value * 2
}

//Есть ещё один метод reduce он служит для того чтобы из коллекции элементов получить какое-нибудь значение тоесть он идеально подходит для того чтобы сложить все элементы коллекции или перемножить между собой
var arr8 = array.reduce(0) { (sum, value)  in
    return sum + value
}
//Тоесть что мы здесь конкретно сделали,мы взяли какое-то первоначальное значение к которому мы случае будем прибавлять наши элементы потом мы взяли промежуточное значение - sum, и то значение которое будет получать каждый следующий элемент
var someArr = [1,2,3,4,5]

var arr10 = someArr.map { (value) -> Int in
    return value * value
}.filter { (value) in
    return value % 2 == 0
}.reduce(0) { (sum, value) in
    return value + sum
}

